This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
Assets.xcassets/
  AccentColor.colorset/
    Contents.json
  AppIcon.appiconset/
    Contents.json
  Contents.json
Models/
  ExerciseDefinition.swift
  Extensions.swift
  SetEntry.swift
  WorkoutRecord.swift
Views/
  AppIconPreviewView.swift
  DataManagementView.swift
  ProgressChartsView.swift
  WorkoutHistoryListView.swift
  WorkoutInputView.swift
  WorkoutSessionDetailView.swift
AppIcon.swift
ContentView.swift
StrengthLog.entitlements
StrengthLogApp.swift
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="Assets.xcassets/AccentColor.colorset/Contents.json">
{
  "colors" : [
    {
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="Assets.xcassets/AppIcon.appiconset/Contents.json">
{
  "images" : [
    {
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "dark"
        }
      ],
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "tinted"
        }
      ],
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "idiom" : "mac",
      "scale" : "1x",
      "size" : "16x16"
    },
    {
      "idiom" : "mac",
      "scale" : "2x",
      "size" : "16x16"
    },
    {
      "idiom" : "mac",
      "scale" : "1x",
      "size" : "32x32"
    },
    {
      "idiom" : "mac",
      "scale" : "2x",
      "size" : "32x32"
    },
    {
      "idiom" : "mac",
      "scale" : "1x",
      "size" : "128x128"
    },
    {
      "idiom" : "mac",
      "scale" : "2x",
      "size" : "128x128"
    },
    {
      "idiom" : "mac",
      "scale" : "1x",
      "size" : "256x256"
    },
    {
      "idiom" : "mac",
      "scale" : "2x",
      "size" : "256x256"
    },
    {
      "idiom" : "mac",
      "scale" : "1x",
      "size" : "512x512"
    },
    {
      "idiom" : "mac",
      "scale" : "2x",
      "size" : "512x512"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="Assets.xcassets/Contents.json">
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="Models/ExerciseDefinition.swift">
import Foundation
import SwiftData

@Model
final class ExerciseDefinition {
    @Attribute(.unique) var id: UUID
    var name: String
    var dateAdded: Date
    
    @Relationship(deleteRule: .cascade) var workoutRecords: [WorkoutRecord] = []
    
    init(name: String, dateAdded: Date = Date()) {
        self.id = UUID()
        self.name = name
        self.dateAdded = dateAdded
    }
}
</file>

<file path="Models/Extensions.swift">
import Foundation

// Helper for number formatters
extension NumberFormatter {
    static var decimal: NumberFormatter {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.maximumFractionDigits = 2
        return formatter
    }

    static var integer: NumberFormatter {
        let formatter = NumberFormatter()
        formatter.numberStyle = .none // No thousands separators for reps
        formatter.maximumFractionDigits = 0
        return formatter
    }
}

// Modified Epley formula: If reps = 1, use actual weight as 1RM
// Otherwise, use Epley formula: 1RM = weight × (1 + reps / 30)
func calculateOneRepMax(weight: Double, reps: Int) -> Double {
    guard reps > 0 else { return weight } // Avoid division by zero or negative reps issues in formula logic
    
    // For 1-rep sets, use the actual weight as the 1RM
    if reps == 1 {
        return weight
    }
    
    // For multiple reps, use the Epley formula
    return weight * (1 + Double(reps) / 30.0)
}
</file>

<file path="Models/SetEntry.swift">
import Foundation
import SwiftData

@Model
final class SetEntry: Identifiable {
    @Attribute(.unique) var id: UUID
    var weight: Double
    var reps: Int
    var calculatedOneRepMax: Double
    
    @Relationship(deleteRule: .nullify) var workoutRecord: WorkoutRecord?
    
    init(weight: Double, reps: Int, workoutRecord: WorkoutRecord? = nil) {
        self.id = UUID()
        self.weight = weight
        self.reps = reps
        self.workoutRecord = workoutRecord
        
        // Apply the 1RM calculation based on reps
        if reps == 1 {
            self.calculatedOneRepMax = weight
        } else {
            self.calculatedOneRepMax = weight * (1 + Double(reps) / 30.0)
        }
    }
    
    // Update one-rep max when weight or reps change
    func updateOneRepMax() {
        self.calculatedOneRepMax = calculateOneRepMax(weight: weight, reps: reps)
    }
    
    // Epley formula: 1RM = weight × (1 + reps / 30)
    private func calculateOneRepMax(weight: Double, reps: Int) -> Double {
        return weight * (1 + Double(reps) / 30)
    }
}
</file>

<file path="Models/WorkoutRecord.swift">
import Foundation
import SwiftData

@Model
final class WorkoutRecord {
    @Attribute(.unique) var id: UUID
    var date: Date
    
    @Relationship(deleteRule: .nullify) var exerciseDefinition: ExerciseDefinition?
    @Relationship(deleteRule: .cascade) var setEntries: [SetEntry] = []
    
    init(date: Date = Date(), exerciseDefinition: ExerciseDefinition? = nil) {
        self.id = UUID()
        self.date = date
        self.exerciseDefinition = exerciseDefinition
    }
    
    var totalVolume: Double {
        setEntries.reduce(0) { $0 + $1.weight * Double($1.reps) }
    }
}

// MARK: - Phase 5: Basic Progress Visualization
extension WorkoutRecord {
    var bestOneRepMaxInSession: Double {
        guard !setEntries.isEmpty else { return 0.0 }
        return setEntries.reduce(0.0) { max($0, $1.calculatedOneRepMax) }
    }
}
</file>

<file path="Views/AppIconPreviewView.swift">
import SwiftUI

struct AppIconPreviewView: View {
    var body: some View {
        VStack(spacing: 20) {
            Text("App Icon Preview")
                .font(.largeTitle)
                .fontWeight(.bold)
            
            AppIcon()
                .frame(width: 300, height: 300)
                .clipShape(RoundedRectangle(cornerRadius: 60))
                .shadow(color: .black.opacity(0.2), radius: 10, x: 0, y: 5)
            
            Text("StrengthLog App Icon")
                .font(.title2)
            
            Text("To use this icon in your app, take a screenshot and add it to your Xcode project's Assets catalog.")
                .font(.caption)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
                .padding(.horizontal)
        }
        .padding()
    }
}

#Preview {
    AppIconPreviewView()
}
</file>

<file path="Views/DataManagementView.swift">
import SwiftUI
import SwiftData
import UniformTypeIdentifiers

struct DataManagementView: View {
    @Environment(\.modelContext) private var modelContext
    @Query private var exercises: [ExerciseDefinition]
    @Query private var workouts: [WorkoutRecord]
    @Query private var sets: [SetEntry]
    
    @State private var exportURL: URL?
    @State private var isExporting = false
    @State private var isImporting = false
    @State private var showingExportSuccess = false
    @State private var showingImportSuccess = false
    @State private var showingError = false
    @State private var errorMessage = ""
    @State private var showingClearConfirmation = false
    
    var body: some View {
        List {
            Section(header: Text("Export Data")) {
                VStack(alignment: .leading, spacing: 8) {
                    Text("Export all your workout data to a JSON file")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                    
                    Button(action: exportData) {
                        Label("Export Data", systemImage: "arrow.up.doc")
                            .frame(maxWidth: .infinity)
                    }
                    .buttonStyle(.borderedProminent)
                    .padding(.vertical, 8)
                }
            }
            
            Section(header: Text("Import Data")) {
                VStack(alignment: .leading, spacing: 8) {
                    Text("Import workout data from a JSON file")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                    
                    Text("Warning: This will replace all existing data")
                        .font(.caption)
                        .foregroundColor(.red)
                    
                    Button(action: { isImporting = true }) {
                        Label("Import Data", systemImage: "arrow.down.doc")
                            .frame(maxWidth: .infinity)
                    }
                    .buttonStyle(.bordered)
                    .padding(.vertical, 8)
                }
            }
            
            Section(header: Text("Clear Data")) {
                VStack(alignment: .leading, spacing: 8) {
                    Text("Delete all exercises and workout records")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                    
                    Text("Warning: This action cannot be undone")
                        .font(.caption)
                        .foregroundColor(.red)
                    
                    Button(action: { showingClearConfirmation = true }) {
                        Label("Clear All Data", systemImage: "trash")
                            .frame(maxWidth: .infinity)
                    }
                    .buttonStyle(.bordered)
                    .foregroundColor(.red)
                    .padding(.vertical, 8)
                }
            }
            
            Section(header: Text("Database Statistics")) {
                HStack {
                    Text("Exercises")
                    Spacer()
                    Text("\(exercises.count)")
                        .foregroundColor(.secondary)
                }
                
                HStack {
                    Text("Workout Records")
                    Spacer()
                    Text("\(workouts.count)")
                        .foregroundColor(.secondary)
                }
                
                HStack {
                    Text("Set Entries")
                    Spacer()
                    Text("\(sets.count)")
                        .foregroundColor(.secondary)
                }
            }
        }
        .navigationTitle("Data Management")
        .fileExporter(
            isPresented: $isExporting,
            document: JSONDocument(initialText: createExportJSON()),
            contentType: .json,
            defaultFilename: "StrengthLog_Export_\(formattedDate())"
        ) { result in
            switch result {
            case .success:
                showingExportSuccess = true
            case .failure(let error):
                errorMessage = error.localizedDescription
                showingError = true
            }
        }
        .fileImporter(
            isPresented: $isImporting,
            allowedContentTypes: [.json],
            allowsMultipleSelection: false
        ) { result in
            switch result {
            case .success(let urls):
                guard let selectedURL = urls.first else { return }
                
                if selectedURL.startAccessingSecurityScopedResource() {
                    defer { selectedURL.stopAccessingSecurityScopedResource() }
                    
                    do {
                        let data = try Data(contentsOf: selectedURL)
                        try importData(from: data)
                        showingImportSuccess = true
                    } catch {
                        errorMessage = error.localizedDescription
                        showingError = true
                    }
                }
            case .failure(let error):
                errorMessage = error.localizedDescription
                showingError = true
            }
        }
        .alert("Export Successful", isPresented: $showingExportSuccess) {
            Button("OK", role: .cancel) { }
        } message: {
            Text("Your data has been successfully exported.")
        }
        .alert("Import Successful", isPresented: $showingImportSuccess) {
            Button("OK", role: .cancel) { }
        } message: {
            Text("Your data has been successfully imported.")
        }
        .alert("Error", isPresented: $showingError) {
            Button("OK", role: .cancel) { }
        } message: {
            Text(errorMessage)
        }
        .alert("Clear All Data", isPresented: $showingClearConfirmation) {
            Button("Cancel", role: .cancel) { }
            Button("Clear", role: .destructive) {
                clearAllData()
            }
        } message: {
            Text("Are you sure you want to delete all exercises and workout records? This action cannot be undone.")
        }
    }
    
    private func exportData() {
        isExporting = true
    }
    
    private func clearAllData() {
        // Delete all exercises (which will cascade delete all workout records and sets due to relationship rules)
        for exercise in exercises {
            modelContext.delete(exercise)
        }
        
        // Try to save the context explicitly to ensure changes are persisted immediately
        do {
            try modelContext.save()
        } catch {
            errorMessage = "Error clearing data: \(error.localizedDescription)"
            showingError = true
        }
    }
    
    private func createExportJSON() -> String {
        do {
            // Create a data structure to represent the export data
            struct ExportData: Codable {
                var exercises: [ExerciseData]
            }
            
            struct ExerciseData: Codable {
                var id: UUID
                var name: String
                var dateAdded: Date
                var workouts: [WorkoutData]
            }
            
            struct WorkoutData: Codable {
                var id: UUID
                var date: Date
                var sets: [SetData]
            }
            
            struct SetData: Codable {
                var id: UUID
                var weight: Double
                var reps: Int
                var calculatedOneRepMax: Double
            }
            
            // Convert the model data to the export structure
            var exportExercises: [ExerciseData] = []
            
            for exercise in exercises {
                var workoutDataArray: [WorkoutData] = []
                
                for workout in exercise.workoutRecords {
                    var setDataArray: [SetData] = []
                    
                    for set in workout.setEntries {
                        let setData = SetData(
                            id: set.id,
                            weight: set.weight,
                            reps: set.reps,
                            calculatedOneRepMax: set.calculatedOneRepMax
                        )
                        setDataArray.append(setData)
                    }
                    
                    let workoutData = WorkoutData(
                        id: workout.id,
                        date: workout.date,
                        sets: setDataArray
                    )
                    workoutDataArray.append(workoutData)
                }
                
                let exerciseData = ExerciseData(
                    id: exercise.id,
                    name: exercise.name,
                    dateAdded: exercise.dateAdded,
                    workouts: workoutDataArray
                )
                exportExercises.append(exerciseData)
            }
            
            let exportData = ExportData(exercises: exportExercises)
            
            // Convert to JSON
            let encoder = JSONEncoder()
            encoder.dateEncodingStrategy = .iso8601
            encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
            let jsonData = try encoder.encode(exportData)
            
            if let jsonString = String(data: jsonData, encoding: .utf8) {
                return jsonString
            }
        } catch {
            errorMessage = "Error creating export data: \(error.localizedDescription)"
            showingError = true
        }
        
        return "{\"error\": \"Failed to create export data\"}"
    }
    
    private func importData(from data: Data) throws {
        // Define the import data structure
        struct ImportData: Codable {
            var exercises: [ExerciseData]
        }
        
        struct ExerciseData: Codable {
            var id: UUID
            var name: String
            var dateAdded: Date
            var workouts: [WorkoutData]
        }
        
        struct WorkoutData: Codable {
            var id: UUID
            var date: Date
            var sets: [SetData]
        }
        
        struct SetData: Codable {
            var id: UUID
            var weight: Double
            var reps: Int
            var calculatedOneRepMax: Double
        }
        
        // Parse the JSON data
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        let importData = try decoder.decode(ImportData.self, from: data)
        
        // Clear existing data
        for exercise in exercises {
            modelContext.delete(exercise)
        }
        
        // Import the new data
        for exerciseData in importData.exercises {
            let exercise = ExerciseDefinition(name: exerciseData.name, dateAdded: exerciseData.dateAdded)
            exercise.id = exerciseData.id
            modelContext.insert(exercise)
            
            for workoutData in exerciseData.workouts {
                let workout = WorkoutRecord(date: workoutData.date, exerciseDefinition: exercise)
                workout.id = workoutData.id
                modelContext.insert(workout)
                
                for setData in workoutData.sets {
                    let set = SetEntry(weight: setData.weight, reps: setData.reps, workoutRecord: workout)
                    set.id = setData.id
                    set.calculatedOneRepMax = setData.calculatedOneRepMax
                    modelContext.insert(set)
                    workout.setEntries.append(set)
                }
                
                exercise.workoutRecords.append(workout)
            }
        }
        
        // Save changes
        try modelContext.save()
    }
    
    private func formattedDate() -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd"
        return formatter.string(from: Date())
    }
}

// Document type for exporting JSON data
struct JSONDocument: FileDocument {
    static var readableContentTypes: [UTType] { [.json] }
    
    var text: String
    
    init(initialText: String = "") {
        text = initialText
    }
    
    init(configuration: ReadConfiguration) throws {
        guard let data = configuration.file.regularFileContents,
              let string = String(data: data, encoding: .utf8)
        else {
            throw CocoaError(.fileReadCorruptFile)
        }
        text = string
    }
    
    func fileWrapper(configuration: WriteConfiguration) throws -> FileWrapper {
        let data = Data(text.utf8)
        return FileWrapper(regularFileWithContents: data)
    }
}

#Preview {
    NavigationView {
        DataManagementView()
            .modelContainer(for: [
                ExerciseDefinition.self,
                WorkoutRecord.self,
                SetEntry.self
            ], inMemory: true)
    }
}
</file>

<file path="Views/ProgressChartsView.swift">
import SwiftUI
import Charts
import SwiftData

struct ProgressChartsView: View {
    @Query var exerciseDefinitions: [ExerciseDefinition]
    @State private var selectedExercise: ExerciseDefinition? = nil
    @State private var selectedDataPoint: (date: Date, value: Double)? = nil
    @State private var chartType: ChartType = .oneRepMax
    @State private var timeRange: TimeRange = .allTime
    
    enum ChartType: String, CaseIterable, Identifiable {
        case oneRepMax = "1RM"
        case volume = "Volume"
        
        var id: String { self.rawValue }
    }
    
    enum TimeRange: String, CaseIterable, Identifiable {
        case month = "1 Month"
        case threeMonths = "3 Months"
        case sixMonths = "6 Months"
        case year = "1 Year"
        case allTime = "All Time"
        
        var id: String { self.rawValue }
        
        var days: Int? {
            switch self {
            case .month: return 30
            case .threeMonths: return 90
            case .sixMonths: return 180
            case .year: return 365
            case .allTime: return nil
            }
        }
    }
    
    var body: some View {
        VStack(alignment: .leading, spacing: 20) {
            if exerciseDefinitions.isEmpty {
                ContentUnavailableView(
                    "No exercises available",
                    systemImage: "chart.xyaxis.line",
                    description: Text("Add exercises first to see your progress charts")
                )
            } else {
                Picker("Select Exercise", selection: $selectedExercise) {
                    ForEach(exerciseDefinitions, id: \.id) { exercise in
                        Text(exercise.name).tag(Optional(exercise))
                    }
                }
                .pickerStyle(.menu)
                .padding(.horizontal)
                .onChange(of: selectedExercise) { _, _ in
                    // Reset selected data point when changing exercise
                    selectedDataPoint = nil
                }
                .onAppear {
                    if selectedExercise == nil, let firstExercise = exerciseDefinitions.first {
                        selectedExercise = firstExercise
                    }
                }
                
                HStack {
                    Picker("Chart Type", selection: $chartType) {
                        ForEach(ChartType.allCases) { type in
                            Text(type.rawValue).tag(type)
                        }
                    }
                    .pickerStyle(.segmented)
                    .frame(maxWidth: .infinity)
                    
                    Picker("Time Range", selection: $timeRange) {
                        ForEach(TimeRange.allCases) { range in
                            Text(range.rawValue).tag(range)
                        }
                    }
                    .pickerStyle(.menu)
                }
                .padding(.horizontal)
                .onChange(of: chartType) { _, _ in
                    // Reset selected data point when changing chart type
                    selectedDataPoint = nil
                }
                .onChange(of: timeRange) { _, _ in
                    // Reset selected data point when changing time range
                    selectedDataPoint = nil
                }
                
                if let exercise = selectedExercise {
                    let records = exercise.workoutRecords
                    if !records.isEmpty {
                        let filteredRecords = filterRecordsByTimeRange(records.sorted(by: { $0.date < $1.date }))
                        
                        if filteredRecords.isEmpty {
                            ContentUnavailableView(
                                "No data in selected time range",
                                systemImage: "chart.xyaxis.line",
                                description: Text("Try selecting a different time range")
                            )
                        } else {
                            // Chart container
                            VStack(alignment: .leading, spacing: 10) {
                                Text(chartTitle)
                                    .font(.headline)
                                    .padding(.horizontal)
                                
                                chartView(for: filteredRecords)
                                    .frame(height: 250)
                                    .padding(.horizontal, 8)
                                
                                // Selected data point information
                                if let selected = selectedDataPoint {
                                    HStack {
                                        VStack(alignment: .leading) {
                                            Text("Date: \(selected.date, format: .dateTime.day().month().year())")
                                                .font(.subheadline)
                                            Text("\(chartType == .oneRepMax ? "1RM" : "Volume"): \(selected.value, specifier: "%.1f")")
                                                .font(.subheadline.bold())
                                        }
                                        Spacer()
                                    }
                                    .padding()
                                    .background(Color(UIColor.secondarySystemBackground))
                                    .cornerRadius(10)
                                    .padding(.horizontal)
                                }
                                
                                // Instructions
                                Text("Tap on a data point for details")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                                    .frame(maxWidth: .infinity, alignment: .center)
                                    .padding(.top, 4)
                            }
                        }
                    } else {
                        ContentUnavailableView(
                            "No workout records",
                            systemImage: "chart.xyaxis.line",
                            description: Text("Log workouts for \(exercise.name) to see progress charts")
                        )
                    }
                } else if !exerciseDefinitions.isEmpty {
                    Text("Please select an exercise to see progress.")
                        .padding()
                } else {
                    Text("No data available.")
                        .padding()
                }
            }
        }
        .padding(.vertical)
        .navigationTitle("Progress Charts")
    }
    
    private func filterRecordsByTimeRange(_ records: [WorkoutRecord]) -> [WorkoutRecord] {
        guard let days = timeRange.days else {
            return records // All time, no filtering
        }
        
        let cutoffDate = Calendar.current.date(byAdding: .day, value: -days, to: Date()) ?? Date()
        return records.filter { $0.date >= cutoffDate }
    }
    
    private var chartTitle: String {
        guard let exercise = selectedExercise else { return "" }
        let typeLabel = chartType == .oneRepMax ? "Estimated 1RM Trend" : "Training Volume Trend"
        return "\(typeLabel) for \(exercise.name) (\(timeRange.rawValue))"
    }
    
    @ViewBuilder
    private func chartView(for records: [WorkoutRecord]) -> some View {
        Chart {
            ForEach(records) { record in
                let yValue = chartType == .oneRepMax ? record.bestOneRepMaxInSession : record.totalVolume
                
                LineMark(
                    x: .value("Date", record.date),
                    y: .value(chartType == .oneRepMax ? "Est. 1RM" : "Volume", yValue)
                )
                .foregroundStyle(chartType == .oneRepMax ? Color.blue : Color.green)
                .interpolationMethod(.catmullRom)
                
                PointMark(
                    x: .value("Date", record.date),
                    y: .value(chartType == .oneRepMax ? "Est. 1RM" : "Volume", yValue)
                )
                .foregroundStyle(chartType == .oneRepMax ? Color.blue : Color.green)
                .symbolSize(selectedDataPoint?.date == record.date ? 150 : 100)
            }
        }
        .chartXAxis {
            AxisMarks(values: .automatic) { value in
                AxisGridLine()
                AxisValueLabel(format: .dateTime.month().day())
            }
        }
        .chartYAxis {
            AxisMarks(position: .leading) { value in
                AxisGridLine()
                AxisValueLabel()
            }
        }
        .chartYScale(domain: .automatic(includesZero: true))
        .chartXScale(domain: .automatic)
        .chartLegend(.hidden)
        .chartOverlay { proxy in
            GeometryReader { geometry in
                Rectangle()
                    .fill(Color.clear)
                    .contentShape(Rectangle())
                    .gesture(
                        DragGesture(minimumDistance: 0)
                            .onChanged { value in
                                let xPosition = value.location.x
                                guard let date = proxy.value(atX: xPosition, as: Date.self) else { return }
                                
                                // Find the closest data point
                                var closestRecord: WorkoutRecord?
                                var minDistance: TimeInterval = .infinity
                                
                                for record in records {
                                    let distance = abs(record.date.timeIntervalSince(date))
                                    if distance < minDistance {
                                        minDistance = distance
                                        closestRecord = record
                                    }
                                }
                                
                                if let record = closestRecord {
                                    let value = chartType == .oneRepMax ? record.bestOneRepMaxInSession : record.totalVolume
                                    selectedDataPoint = (date: record.date, value: value)
                                }
                            }
                    )
            }
        }
    }
}

struct ProgressChartsView_Previews: PreviewProvider {
    @MainActor // Ensures Core Data/SwiftData access is on the main thread for previews
    static func createSampleData(modelContext: ModelContext) {
        let sampleExercise1 = ExerciseDefinition(name: "Bench Press")
        let sampleExercise2 = ExerciseDefinition(name: "Squat")
        modelContext.insert(sampleExercise1)
        modelContext.insert(sampleExercise2)
        
        let record1Ex1 = WorkoutRecord(date: Calendar.current.date(byAdding: .day, value: -10, to: Date())!, exerciseDefinition: sampleExercise1)
        let set1Ex1Rec1 = SetEntry(weight: 80, reps: 5, workoutRecord: record1Ex1)
        modelContext.insert(record1Ex1) // Insert parent first
        modelContext.insert(set1Ex1Rec1) // Insert child
        // SwiftData should automatically link relationships if defined correctly.
        // If manual linking is needed (e.g. one-way or specific cases):
        // record1Ex1.setEntries.append(set1Ex1Rec1) 
        // sampleExercise1.workoutRecords.append(record1Ex1)

        let record2Ex1 = WorkoutRecord(date: Calendar.current.date(byAdding: .day, value: -5, to: Date())!, exerciseDefinition: sampleExercise1)
        let set1Ex1Rec2 = SetEntry(weight: 85, reps: 5, workoutRecord: record2Ex1)
        modelContext.insert(record2Ex1)
        modelContext.insert(set1Ex1Rec2)
        // record2Ex1.setEntries.append(set1Ex1Rec2)
        // sampleExercise1.workoutRecords.append(record2Ex1)
        
        // Add a record for the second exercise to test selection
        let record1Ex2 = WorkoutRecord(date: Calendar.current.date(byAdding: .day, value: -7, to: Date())!, exerciseDefinition: sampleExercise2)
        let set1Ex2Rec1 = SetEntry(weight: 100, reps: 5, workoutRecord: record1Ex2)
        modelContext.insert(record1Ex2)
        modelContext.insert(set1Ex2Rec1)
        // record1Ex2.setEntries.append(set1Ex2Rec1)
        // sampleExercise2.workoutRecords.append(record1Ex2)
    }

    static var previews: some View {
        // This is the more modern #Preview macro style. 
        // If your project uses the older PreviewProvider struct, the .modelContainer approach is fine.
        // For clarity and to avoid buildExpression errors, we separate data setup.
        
        // Setup for PreviewProvider struct:
        let config = ModelConfiguration(isStoredInMemoryOnly: true)
        let container = try! ModelContainer(for: ExerciseDefinition.self, WorkoutRecord.self, SetEntry.self, configurations: config)
        createSampleData(modelContext: container.mainContext) // Populate with data

        return ProgressChartsView()
            .modelContainer(container)
    }
}
</file>

<file path="Views/WorkoutHistoryListView.swift">
import SwiftUI
import SwiftData

struct WorkoutHistoryListView: View {
    @Query(sort: [SortDescriptor(\WorkoutRecord.date, order: .reverse)]) var workoutRecords: [WorkoutRecord]

    var body: some View {
        List {
            ForEach(workoutRecords) { record in
                NavigationLink {
                    WorkoutSessionDetailView(workoutRecord: record)
                } label: {
                    HStack {
                        VStack(alignment: .leading) {
                            Text(record.exerciseDefinition?.name ?? "Unknown Exercise")
                                .font(.headline)
                            Text(record.date, format: .dateTime.day().month().year())
                                .font(.subheadline)
                                .foregroundColor(.secondary)
                        }
                        Spacer()
                        VStack(alignment: .trailing) {
                            Text("\(record.setEntries.count) sets")
                                .font(.subheadline)
                            Text("Volume: \(record.totalVolume, format: .number.precision(.fractionLength(1)))")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                    }
                    .padding(.vertical, 4)
                }
            }
        }
        .navigationTitle("Workout History")
    }
}

#Preview {
    let config = ModelConfiguration(isStoredInMemoryOnly: true)
    let container = try! ModelContainer(for: ExerciseDefinition.self, WorkoutRecord.self, SetEntry.self, configurations: config)
    WorkoutHistoryListView()
        .modelContainer(container)
}
</file>

<file path="Views/WorkoutInputView.swift">
import SwiftUI
import SwiftData
import Foundation

struct WorkoutInputView: View {
    @Environment(\.modelContext) private var modelContext
    @Environment(\.dismiss) var dismiss

    var exerciseDefinition: ExerciseDefinition

    @State private var workoutDate: Date = Date()
    @State private var sets: [TemporarySetEntry] = []
    @State private var weightString: String = ""
    @State private var repsString: String = ""
    
    // Computed property for current total volume
    var currentTotalVolume: Double {
        sets.reduce(0) { $0 + ($1.weight * Double($1.reps)) }
    }
    
    // Temporary struct to hold set data before saving
    struct TemporarySetEntry: Identifiable {
        let id = UUID()
        var weight: Double
        var reps: Int
        var oneRepMax: Double {
            calculateOneRepMax(weight: weight, reps: reps)
        }
    }

    var body: some View {
        NavigationView {
            Form {
                Section(header: Text("Workout Details")) {
                    DatePicker("Date", selection: $workoutDate, displayedComponents: .date)
                }

                Section(header: Text("Add Set")) {
                    HStack {
                        Text("Weight:")
                        TextField("kg/lbs", text: $weightString)
                            .keyboardType(.decimalPad)
                            .multilineTextAlignment(.trailing)
                    }
                    HStack {
                        Text("Reps:")
                        TextField("Count", text: $repsString)
                            .keyboardType(.numberPad)
                            .multilineTextAlignment(.trailing)
                    }
                    Button("Add Set") {
                        addSet()
                    }
                    .disabled(!isValidInput())
                }

                if !sets.isEmpty {
                    Section(header: Text("Logged Sets (\(sets.count))")) {
                        List {
                            ForEach(sets) { set in
                                HStack {
                                    Text("\(set.weight, specifier: "%.1f") kg/lbs x \(set.reps) reps")
                                    Spacer()
                                    Text("1RM: \(set.oneRepMax, specifier: "%.1f")")
                                        .font(.caption)
                                        .foregroundColor(.secondary)
                                }
                            }
                            .onDelete(perform: deleteSet)
                        }
                    }
                }

                Section(header: Text("Total Volume")) {
                    Text("\(currentTotalVolume, format: .number.precision(.fractionLength(1)))")
                        .font(.title2)
                        .padding(.vertical, 4)
                }
            }
            .navigationTitle("Log Workout: \(exerciseDefinition.name)")
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Save Workout") {
                        saveWorkout()
                    }
                    .disabled(sets.isEmpty)
                }
            }
        }
    }
    
    private func isValidInput() -> Bool {
        guard let weight = Double(weightString.trimmingCharacters(in: .whitespaces)),
              let reps = Int(repsString.trimmingCharacters(in: .whitespaces)),
              weight > 0,
              reps > 0 else {
            return false
        }
        return true
    }

    private func addSet() {
        guard let weight = Double(weightString.trimmingCharacters(in: .whitespaces)),
              let reps = Int(repsString.trimmingCharacters(in: .whitespaces)),
              weight > 0,
              reps > 0 else {
            return
        }
        
        let newSet = TemporarySetEntry(weight: weight, reps: reps)
        sets.append(newSet)
        
        // Keep the values for easier entry of multiple sets with similar values
        // User can edit as needed for the next set
    }

    private func deleteSet(at offsets: IndexSet) {
        sets.remove(atOffsets: offsets)
    }

    private func saveWorkout() {
        // Create the workout record
        let newWorkoutRecord = WorkoutRecord(date: workoutDate, exerciseDefinition: exerciseDefinition)
        modelContext.insert(newWorkoutRecord)

        // Add all sets to the workout record
        for tempSet in sets {
            let setEntry = SetEntry(weight: tempSet.weight, reps: tempSet.reps, workoutRecord: newWorkoutRecord)
            modelContext.insert(setEntry)
            newWorkoutRecord.setEntries.append(setEntry)
        }
        
        // Explicitly add the workout record to the exercise's workoutRecords array
        // This ensures the relationship is properly established in both directions
        exerciseDefinition.workoutRecords.append(newWorkoutRecord)
        
        // Try to save the context explicitly to ensure changes are persisted immediately
        do {
            try modelContext.save()
        } catch {
            print("Error saving workout: \(error)")
        }
        
        // Dismiss the view after saving
        dismiss()
    }
}

// Preview needs an ExerciseDefinition.
#Preview {
    // Create a dummy ExerciseDefinition for the preview
    let config = ModelConfiguration(isStoredInMemoryOnly: true)
    let container = try! ModelContainer(for: ExerciseDefinition.self, WorkoutRecord.self, SetEntry.self, configurations: config)
    let exampleExercise = ExerciseDefinition(name: "Bench Press")
    // It's important to insert the exampleExercise into the context if WorkoutInputView or its children might try to use its modelContext.
    // However, for this specific preview, WorkoutInputView primarily uses the passed exerciseDefinition for its name and to link upon saving.
    // If the view were to, for example, immediately fetch related data *from* the exerciseDefinition using its context, insertion would be critical here.
    // For now, just passing it should be fine for display and initial interaction.
    // container.mainContext.insert(exampleExercise) // Uncomment if issues arise related to model context from exercise.
    
    WorkoutInputView(exerciseDefinition: exampleExercise)
        .modelContainer(container) // Provide the container to the view hierarchy for @Environment(\.modelContext).
}
</file>

<file path="Views/WorkoutSessionDetailView.swift">
import SwiftUI
import SwiftData
import Foundation

struct WorkoutSessionDetailView: View {
    @Environment(\.modelContext) private var modelContext
    var workoutRecord: WorkoutRecord
    @State private var selectedSet: SetEntry? = nil
    @State private var isEditingSet: Bool = false
    @State private var editingWeight: Double = 0
    @State private var editingReps: Int = 0
    @State private var isEditingDate: Bool = false
    @State private var editingDate: Date = Date()

    var body: some View {
        VStack(alignment: .leading) {
            Text(workoutRecord.exerciseDefinition?.name ?? "Unknown Exercise")
                .font(.largeTitle)
                .padding(.bottom, 2)

            Text(workoutRecord.date, format: .dateTime.day().month().year())
                .font(.headline)
                .padding(.bottom, 10)

            List {
                Section(header: Text("Sets")) {
                    ForEach(workoutRecord.setEntries) { set in
                        HStack {
                            Text("\(set.weight, format: .number.precision(.fractionLength(1))) × \(set.reps) reps")
                            Spacer()
                            Text("1RM: \(set.calculatedOneRepMax, format: .number.precision(.fractionLength(1)))")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                        .padding(.vertical, 4)
                        .contentShape(Rectangle()) // Make the entire row tappable
                        .onTapGesture {
                            selectedSet = set
                            editingWeight = set.weight
                            editingReps = set.reps
                            isEditingSet = true
                        }
                    }
                    .onDelete { indexSet in
                        for index in indexSet {
                            let setToDelete = workoutRecord.setEntries[index]
                            modelContext.delete(setToDelete)
                            workoutRecord.setEntries.remove(at: index)
                        }
                    }
                }

                Section(header: Text("Total Volume")) {
                    Text("\(workoutRecord.totalVolume, format: .number.precision(.fractionLength(1)))")
                        .font(.title2)
                        .padding(.vertical, 4)
                }
            }
        }
        .navigationTitle("Session Details")
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Button(action: {
                    editingDate = workoutRecord.date
                    isEditingDate = true
                }) {
                    Label("Edit Date", systemImage: "calendar")
                }
            }
        }
        .sheet(isPresented: $isEditingSet) {
            NavigationView {
                Form {
                    Section(header: Text("Edit Set")) {
                        HStack {
                            Text("Weight:")
                            TextField("kg/lbs", value: $editingWeight, formatter: NumberFormatter.decimal)
                                .keyboardType(.decimalPad)
                                .multilineTextAlignment(.trailing)
                        }
                        HStack {
                            Text("Reps:")
                            TextField("Count", value: $editingReps, formatter: NumberFormatter.integer)
                                .keyboardType(.numberPad)
                                .multilineTextAlignment(.trailing)
                        }
                    }
                }
                .navigationTitle("Edit Set")
                .navigationBarTitleDisplayMode(.inline)
                .toolbar {
                    ToolbarItem(placement: .navigationBarLeading) {
                        Button("Cancel") {
                            isEditingSet = false
                        }
                    }
                    ToolbarItem(placement: .navigationBarTrailing) {
                        Button("Save") {
                            if let set = selectedSet {
                                set.weight = editingWeight
                                set.reps = editingReps
                                set.updateOneRepMax()
                            }
                            isEditingSet = false
                        }
                        .disabled(editingWeight <= 0 || editingReps <= 0)
                    }
                }
            }
        }
        .sheet(isPresented: $isEditingDate) {
            NavigationView {
                Form {
                    Section(header: Text("Edit Workout Date")) {
                        DatePicker("Date", selection: $editingDate, displayedComponents: .date)
                    }
                }
                .navigationTitle("Edit Date")
                .navigationBarTitleDisplayMode(.inline)
                .toolbar {
                    ToolbarItem(placement: .navigationBarLeading) {
                        Button("Cancel") {
                            isEditingDate = false
                        }
                    }
                    ToolbarItem(placement: .navigationBarTrailing) {
                        Button("Save") {
                            workoutRecord.date = editingDate
                            isEditingDate = false
                        }
                    }
                }
            }
        }
    }
}

#Preview {
    // Group all setup logic
    let (record, container) = {
        let config = ModelConfiguration(isStoredInMemoryOnly: true)
        let container = try! ModelContainer(for: ExerciseDefinition.self, WorkoutRecord.self, SetEntry.self, configurations: config)
        let exercise = ExerciseDefinition(name: "Bench Press")
        let record = WorkoutRecord(date: Date(), exerciseDefinition: exercise)
        let set1 = SetEntry(weight: 80, reps: 8, workoutRecord: record)
        let set2 = SetEntry(weight: 85, reps: 5, workoutRecord: record)
        
        container.mainContext.insert(exercise)
        container.mainContext.insert(record)
        container.mainContext.insert(set1)
        container.mainContext.insert(set2)
        
        record.setEntries.append(set1)
        record.setEntries.append(set2)
        
        return (record, container) // Return the necessary data
    }()

    // Ensure the view is returned properly
    return WorkoutSessionDetailView(workoutRecord: record)
        .modelContainer(container)
}
</file>

<file path="AppIcon.swift">
import SwiftUI

struct AppIcon: View {
    var body: some View {
        ZStack {
            // Background gradient
            LinearGradient(
                gradient: Gradient(colors: [Color(hex: "1A2980"), Color(hex: "26D0CE")]),
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            
            // Dumbbell design
            HStack(spacing: 12) {
                // Left weight
                WeightPlate()
                
                // Bar
                RoundedRectangle(cornerRadius: 6)
                    .fill(Color.white.opacity(0.9))
                    .frame(width: 80, height: 12)
                
                // Right weight
                WeightPlate()
            }
            
            // App name at bottom
            VStack {
                Spacer()
                Text("STRENGTH LOG")
                    .font(.system(size: 24, weight: .heavy, design: .rounded))
                    .foregroundColor(.white)
                    .padding(.bottom, 40)
            }
        }
        .frame(width: 1024, height: 1024)
    }
}

struct WeightPlate: View {
    var body: some View {
        ZStack {
            // Outer ring
            Circle()
                .fill(Color.gray.opacity(0.8))
                .frame(width: 120, height: 120)
            
            // Inner ring
            Circle()
                .fill(Color.black.opacity(0.7))
                .frame(width: 100, height: 100)
            
            // Center hole
            Circle()
                .fill(Color.white.opacity(0.9))
                .frame(width: 20, height: 20)
        }
        .shadow(color: .black.opacity(0.5), radius: 10, x: 0, y: 5)
    }
}

// Helper extension to create colors from hex values
extension Color {
    init(hex: String) {
        let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
        var int: UInt64 = 0
        Scanner(string: hex).scanHexInt64(&int)
        let a, r, g, b: UInt64
        switch hex.count {
        case 3: // RGB (12-bit)
            (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17)
        case 6: // RGB (24-bit)
            (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF)
        case 8: // ARGB (32-bit)
            (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF)
        default:
            (a, r, g, b) = (1, 1, 1, 0)
        }

        self.init(
            .sRGB,
            red: Double(r) / 255,
            green: Double(g) / 255,
            blue: Double(b) / 255,
            opacity: Double(a) / 255
        )
    }
}

// Preview for the app icon
struct AppIcon_Previews: PreviewProvider {
    static var previews: some View {
        AppIcon()
            .previewLayout(.fixed(width: 1024, height: 1024))
    }
}
</file>

<file path="ContentView.swift">
//
//  ContentView.swift
//  StrengthLog
//
//  Created by Aditya Mishra on 5/13/25.
//

import SwiftUI
import SwiftData

struct ContentView: View {
    @Environment(\.modelContext) private var modelContext
    @Query private var exercises: [ExerciseDefinition]
    @State private var selectedExercise: ExerciseDefinition? = nil
    @State private var isEditingExerciseName: Bool = false
    @State private var editingName: String = ""
    @State private var isAddingExercise: Bool = false
    @State private var newExerciseName: String = ""

    var body: some View {
        NavigationSplitView {
            List {
                Section(header: Text("Features")) {
                    NavigationLink {
                        WorkoutHistoryListView()
                    } label: {
                        Label("Workout History", systemImage: "clock")
                    }
                    
                    NavigationLink {
                        ProgressChartsView()
                    } label: {
                        Label("Progress Charts", systemImage: "chart.xyaxis.line")
                    }
                    
                    NavigationLink {
                        DataManagementView()
                    } label: {
                        Label("Data Management", systemImage: "square.and.arrow.up.on.square")
                    }
                }
                
                Section(header: Text("My Exercises")) {
                    ForEach(exercises) { exercise in
                        NavigationLink {
                            ExerciseDetailView(exercise: exercise)
                        } label: {
                            VStack(alignment: .leading) {
                                Text(exercise.name)
                                    .font(.headline)
                                Text("Added: \(exercise.dateAdded, format: .dateTime.day().month().year())")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                            .contextMenu {
                                Button(action: {
                                    selectedExercise = exercise
                                    editingName = exercise.name
                                    isEditingExerciseName = true
                                }) {
                                    Label("Edit Name", systemImage: "pencil")
                                }
                            }
                        }
                    }
                    .onDelete(perform: deleteExercise)
                }
            }
            .navigationTitle("StrengthLog")
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    EditButton()
                }
                ToolbarItem {
                    Button(action: promptForNewExercise) {
                        Label("Add Exercise", systemImage: "plus")
                    }
                }
            }
            .sheet(isPresented: $isEditingExerciseName) {
                NavigationView {
                    Form {
                        Section(header: Text("Edit Exercise Name")) {
                            TextField("Exercise Name", text: $editingName)
                                .textInputAutocapitalization(.words)
                        }
                    }
                    .navigationTitle("Edit Exercise")
                    .navigationBarTitleDisplayMode(.inline)
                    .toolbar {
                        ToolbarItem(placement: .navigationBarLeading) {
                            Button("Cancel") {
                                isEditingExerciseName = false
                            }
                        }
                        ToolbarItem(placement: .navigationBarTrailing) {
                            Button("Save") {
                                if let exercise = selectedExercise {
                                    exercise.name = editingName
                                }
                                isEditingExerciseName = false
                            }
                            .disabled(editingName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
                        }
                    }
                }
            }
            .sheet(isPresented: $isAddingExercise) {
                NavigationView {
                    Form {
                        Section(header: Text("New Exercise Name")) {
                            TextField("Exercise Name", text: $newExerciseName)
                                .textInputAutocapitalization(.words)
                        }
                    }
                    .navigationTitle("Add Exercise")
                    .navigationBarTitleDisplayMode(.inline)
                    .toolbar {
                        ToolbarItem(placement: .navigationBarLeading) {
                            Button("Cancel") {
                                newExerciseName = ""
                                isAddingExercise = false
                            }
                        }
                        ToolbarItem(placement: .navigationBarTrailing) {
                            Button("Save") {
                                addExercise(name: newExerciseName)
                                newExerciseName = ""
                                isAddingExercise = false
                            }
                            .disabled(newExerciseName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
                        }
                    }
                }
            }
        } detail: {
            Text("Select an exercise to view workout records")
        }
    }

    private func promptForNewExercise() {
        newExerciseName = ""
        isAddingExercise = true
    }

    private func addExercise(name: String) {
        withAnimation {
            let newExercise = ExerciseDefinition(name: name)
            modelContext.insert(newExercise)
        }
    }

    private func deleteExercise(offsets: IndexSet) {
        withAnimation {
            for index in offsets {
                modelContext.delete(exercises[index])
            }
        }
    }
}

struct ExerciseDetailView: View {
    @Environment(\.modelContext) private var modelContext
    var exercise: ExerciseDefinition
    @State private var showingAddWorkoutSheet = false
    @State private var showingDeleteConfirmation = false
    @State private var workoutToDelete: WorkoutRecord? = nil
    
    // Computed properties for best performance metrics
    private var bestOneRepMaxData: (value: Double, date: Date)? {
        guard !exercise.workoutRecords.isEmpty else { return nil }
        
        var bestOneRM: Double = 0
        var bestDate: Date = Date()
        var foundValidOneRM = false
        
        for workout in exercise.workoutRecords {
            for setEntry in workout.setEntries {
                if setEntry.calculatedOneRepMax > bestOneRM {
                    bestOneRM = setEntry.calculatedOneRepMax
                    bestDate = workout.date
                    foundValidOneRM = true
                }
            }
        }
        
        return foundValidOneRM ? (value: bestOneRM, date: bestDate) : nil
    }
    
    private var bestVolumeWorkout: (volume: Double, date: Date)? {
        guard !exercise.workoutRecords.isEmpty else { return nil }
        
        let workoutWithMaxVolume = exercise.workoutRecords.max { $0.totalVolume < $1.totalVolume }
        if let workout = workoutWithMaxVolume {
            return (volume: workout.totalVolume, date: workout.date)
        }
        return nil
    }

    var body: some View {
        VStack {
            if !exercise.workoutRecords.isEmpty {
                // Summary card for best performance metrics
                VStack(spacing: 10) {
                    Text("Personal Records")
                        .font(.headline)
                        .padding(.top, 8)
                    
                    HStack(spacing: 20) {
                        VStack {
                            Text("Best 1RM")
                                .font(.subheadline)
                            if let bestOneRM = bestOneRepMaxData {
                                Text("\(bestOneRM.value, specifier: "%.1f")")
                                    .font(.title3.bold())
                                    .foregroundColor(.blue)
                                Text("\(bestOneRM.date, format: .dateTime.day().month())")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            } else {
                                Text("N/A")
                                    .font(.title3)
                                    .foregroundColor(.secondary)
                            }
                        }
                        .frame(maxWidth: .infinity)
                        
                        Divider().frame(height: 40)
                        
                        VStack {
                            Text("Best Volume")
                                .font(.subheadline)
                            if let bestVolume = bestVolumeWorkout {
                                Text("\(bestVolume.volume, specifier: "%.1f")")
                                    .font(.title3.bold())
                                    .foregroundColor(.green)
                                Text("\(bestVolume.date, format: .dateTime.day().month())")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            } else {
                                Text("N/A")
                                    .font(.title3)
                                    .foregroundColor(.secondary)
                            }
                        }
                        .frame(maxWidth: .infinity)
                    }
                    .padding(.horizontal)
                    .padding(.bottom, 8)
                }
                .background(Color(UIColor.secondarySystemBackground))
                .cornerRadius(10)
                .padding(.horizontal)
                .padding(.bottom, 8)
            }
            
            if exercise.workoutRecords.isEmpty {
                ContentUnavailableView(
                    "No workouts yet",
                    systemImage: "dumbbell",
                    description: Text("Tap the + button to log your first workout")
                )
            } else {
                List {
                    ForEach(exercise.workoutRecords.sorted(by: { $0.date > $1.date })) { workout in
                        VStack(alignment: .leading, spacing: 6) {
                            Text("Date: \(workout.date, format: .dateTime.day().month().year())")
                                .font(.headline)
                            
                            HStack {
                                VStack(alignment: .leading) {
                                    Text("Sets: \(workout.setEntries.count)")
                                        .font(.subheadline)
                                    
                                    Text("Total Volume: \(workout.totalVolume, specifier: "%.1f")")
                                        .font(.subheadline)
                                }
                                
                                Spacer()
                                
                                VStack(alignment: .trailing) {
                                    Text("Best 1RM:")
                                        .font(.subheadline)
                                    
                                    Text("\(workout.bestOneRepMaxInSession, specifier: "%.1f")")
                                        .font(.subheadline.bold())
                                        .foregroundColor(.blue)
                                }
                            }
                        }
                        .padding(.vertical, 4)
                        .contextMenu {
                            Button(role: .destructive) {
                                workoutToDelete = workout
                                showingDeleteConfirmation = true
                            } label: {
                                Label("Delete Workout", systemImage: "trash")
                            }
                        }
                        .swipeActions(edge: .trailing, allowsFullSwipe: false) {
                            Button(role: .destructive) {
                                workoutToDelete = workout
                                showingDeleteConfirmation = true
                            } label: {
                                Label("Delete", systemImage: "trash")
                            }
                        }
                    }
                }
                .alert("Delete Workout", isPresented: $showingDeleteConfirmation) {
                    Button("Cancel", role: .cancel) {
                        workoutToDelete = nil
                    }
                    Button("Delete", role: .destructive) {
                        if let workout = workoutToDelete {
                            deleteWorkout(workout)
                            workoutToDelete = nil
                        }
                    }
                } message: {
                    Text("Are you sure you want to delete this workout? This action cannot be undone.")
                }
            }
            
            Spacer()
            
            Button(action: {
                showingAddWorkoutSheet = true
            }) {
                Label("Add Workout", systemImage: "plus")
                    .frame(maxWidth: .infinity)
            }
            .buttonStyle(.borderedProminent)
            .padding()
        }
        .navigationTitle(exercise.name)
        .sheet(isPresented: $showingAddWorkoutSheet) {
            WorkoutInputView(exerciseDefinition: exercise)
        }
    }
    
    private func deleteWorkout(_ workout: WorkoutRecord) {
        // Remove the workout from the exercise's workoutRecords array
        if let index = exercise.workoutRecords.firstIndex(where: { $0.id == workout.id }) {
            exercise.workoutRecords.remove(at: index)
        }
        
        // Delete the workout from the model context
        modelContext.delete(workout)
        
        // Try to save the context explicitly to ensure changes are persisted immediately
        do {
            try modelContext.save()
        } catch {
            print("Error deleting workout: \(error)")
        }
    }
}

#Preview {
    ContentView()
        .modelContainer(for: [
            ExerciseDefinition.self,
            WorkoutRecord.self,
            SetEntry.self
        ], inMemory: true)
}
</file>

<file path="StrengthLog.entitlements">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>com.apple.security.app-sandbox</key>
    <true/>
    <key>com.apple.security.files.user-selected.read-only</key>
    <true/>
</dict>
</plist>
</file>

<file path="StrengthLogApp.swift">
//
//  StrengthLogApp.swift
//  StrengthLog
//
//  Created by Aditya Mishra on 5/13/25.
//

import SwiftUI
import SwiftData

@main
struct StrengthLogApp: App {
    var sharedModelContainer: ModelContainer = {
        let schema = Schema([
            ExerciseDefinition.self,
            WorkoutRecord.self,
            SetEntry.self
        ])
        let modelConfiguration = ModelConfiguration(schema: schema, isStoredInMemoryOnly: false)

        do {
            return try ModelContainer(for: schema, configurations: [modelConfiguration])
        } catch {
            fatalError("Could not create ModelContainer: \(error)")
        }
    }()

    var body: some Scene {
        WindowGroup {
            ContentView()
        }
        .modelContainer(sharedModelContainer)
    }
}
</file>

</files>
